module Interface where

import           Control.Exception (try)
import           Element
import           Env
import           GenOptProblem
import           Style
import           Substance
import           Sugarer
import           System.IO.Unsafe  (unsafePerformIO)
import           Utils
import           Control.Exception


-- | Given Substance, Style, and Element programs, output an initial state.
-- TODO: rewrite this to be cleaner: (EitherT monad?)
compileTrio ::
     String -- ^ a Substance program
  -> String -- ^ a Style program
  -> String -- ^ an Element program
  -> Either CompilerError State -- ^ an initial state generated by the backend (errors will be included in the state somehow)
compileTrio substance style element = do
  env <- parseElement "" element
  styProg <- parseStyle "" style env
  subOut@(SubOut _ (subEnv, _) _) <-
    parseSubstance "" (sugarStmts substance env) env
  let optConfig = defaultOptConfig
  let styRes =
        unsafePerformIO $ -- Rewrite this such that it's safe
        try (compileStyle styProg subOut [] optConfig) :: Either ErrorCall State
  case styRes of
    Right initState -> Right initState
    Left styRTError -> Left $ StyleTypecheck $ show styRTError

step ::
     State -- ^ the initial state
  -> Int -- ^ the number of steps n for the optimizer to take
  -> State -- ^ the resulting state after the optimizer takes n steps
step initState steps = error ""

stepUntilConvergence ::
     State -- ^ the initial state
  -> Either State OptimizerError -- ^ the converged state or optimizer errors
stepUntilConvergence initState = error ""
