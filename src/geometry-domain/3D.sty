Colors {
    -- Keenan palette
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.midnightblue = rgba(0.14, 0.16, 0.52, 1.0)
    Colors.lightslategray = rgba(0.50, 0.51, 0.69, 1.0)
    Colors.silver = rgba(0.71, 0.72, 0.79, 1.0)
    Colors.gainsboro = rgba(0.87, 0.87, 0.87, 1.0)

    -- Colors.darkgray = rgba(0.1, 0.1, 0.1, 1.0)
    -- Colors.gray = rgba(0.8, 0.8, 0.8, 1.0)
    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.pink = rgba(1.0, 0.4, 0.7, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    -- Colors.lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.sky = rgba(0.325, 0.718, 0.769, 1.0)
    -- Colors.lightsky = rgba(0.325, 0.718, 0.769, 0.25)
    -- Colors.lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    -- Colors.cyan = rgba(0.0, 1.0, 1.0, 1.0)
    -- Colors.purple = rgba(0.5, 0.0, 0.5, 1.0)
    -- Colors.lightpurple = rgba(0.5, 0.0, 0.5, 0.25)
    -- Colors.white = rgba(1.0, 1.0, 1.0, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
    -- Colors.bluegreen = rgba(0.44, 0.68, 0.60, 1.0)
}

global {
    global.padding = 20.0
    global.stroke = 2.0
    global.spacing = 150.0
    global.scaleFactor = 100.0
    global.pi = 3.14159
    global.two_pi = 6.28319

    global.dist_to_sphere = 1.5
    global.camera_z = global.dist_to_sphere + global.sphereRadius
    global.camera = [0.0, 0.0, -1.0 * global.camera_z]     -- x, y, z in math space 
    		  -- Note: Sphere has r=0.5, so the camera needs to be at sufficient distance from the sphere to be able to project on the near plane z=1
    global.dir = [0.0, 0.0, 1.0] -- looking down the +z-axis
    global.sphereRadius = 0.5
    global.hfov = (-5.0, 5.0)
    global.vfov = (-5.0, 5.0)

    global.toScreen = 400.0

    global.test = Circle {
    		x : 0.0
		y : 0.0
		r : (global.sphereRadius * global.toScreen / 2.0) 
		-- TODO: I think this is halved because the projective plane is at z=1 and the widest part of the sphere is at z=2
		color : setOpacity(Colors.blue, 0.2)
		strokeWidth : 1.0
		strokeColor : Colors.black
    }

    global.dof = ?
}

Point p {
      -- Point on sphere
      p.theta = ? -- In radians, the angle CCW off the x-axis. This should be sampled properly with angle_sampler.
      p.phi = ? -- In radians, the angle CW off the z-axis. TODO: custom sampler for optimized vals

      p.sphereCoords = (mod(p.theta, global.two_pi), mod(p.phi, global.pi))
      p.xyz = convertAndProjectAndToScreen(global.hfov, global.vfov, global.sphereRadius, global.camera, global.dir, p.sphereCoords)

      -- p.xyz = polarToCartesian(global.sphere_radius, p.sphereCoords)
      -- p.loc2_mathspace = project(global.camera, p.loc3) -- 2-tuple
      -- p.loc2_screenspace = toScreenSpace(global.hfov, global.vfov, p.loc2_mathspace) -- 2-tuple

      -- TODO: open parser issue: no inline exprs here?
       p.shape = Circle {
         x : (get(p.xyz, 0) * global.toScreen)
	 y : (get(p.xyz, 1) * global.toScreen)
	       -- z in [-0.5,0.5] -> [1.5, 2.5] -> [3, 10]
         r : scaleLinear(get(p.xyz, 2), (-1.0 * global.sphereRadius + global.camera_z, global.sphereRadius + global.camera_z), (3.0, 10.0))
	 color : setOpacity(Colors.red, 0.4)
	 strokeWidth : 1.0
	 strokeColor : Colors.black
       }

       p.text = Text {
	 x : p.shape.x + global.padding
	 y : p.shape.y + global.padding
	 string : p.label
	 rotation : 0.0
	 color : p.shape.color
       }

       -- p.posFn = ensure onCanvas(p.shape)
}

Point `p` {
      -- Which axis faces which way?
      -- Do these angles look as they should?
      -- Does the interpolation failure have to do with the periodicity of the angles?

      -- (0,0) is center of circle
      -- override `p`.theta = 0.0
      -- override `p`.phi = global.pi / 3.0
}

Point `q` {
      -- override `q`.theta = global.pi -- Radians, increasing CCW, starting on the right
      -- override `q`.phi = global.pi / 4.0 -- Widest part of circle at pi/2
}

Segment e
where e := MkSegment(p, q)
with Point p; Point q {
     -- Line on sphere. (Arc of a circle, or a geodesic)
     -- Interpolate between each one's sphere coords to yield several points
     -- then project all of them into screen space

     e.numPts = 20
     e.spherePath = slerp(p.sphereCoords, q.sphereCoords, e.numPts)
     e.screenspacePath = convertAndProjectAndToScreen_list(global.hfov, global.vfov, global.sphereRadius, global.camera, global.dir, e.spherePath, global.toScreen)

     -- Draw a path using the slerp'ed points
     e.shape = Curve {
     	     pathData : pathFromPoints(e.screenspacePath)
	     strokeWidth : 2.0
	     fill : Colors.none
	     color : Colors.midnightblue
	     rotation : 0.0
     }

     -- e.text = Text {
     --   x = midpointX(e.shape) + global.padding
     --   y = midpointY(e.shape) + global.padding
     --   string = e.label
     --   rotation = 0.0
     -- }

     e.layering1 = p.shape above e.shape
     e.layering2 = q.shape above e.shape
}


