Point p {
    p.shape = AnchorPoint { }
}

Set `domainOuter` {
    `domainOuter`.shape = Arrow {
        startX = -100.0
        startY = 0.0
        endX   = 325.0
        endY   = 0.0
        thickness = 10.0
    }
    `domainOuter`.text = Text { string = `domainOuter`.label }
    `domainOuter`.nearFn = encourage nearHead(`domainOuter`.shape, `domainOuter`.text, 15.0, 0.0)
}

Set `codomain` {
    `codomain`.shape = Arrow {
          startX = -100.0
          startY = 0.0
          endX   = -100.0
          endY   = 200.0
          thickness = 10.0          
    }

    -- TODO: refactor rendering code and uncomment
    -- `codomain`.angleNotation = Arc {
        -- x = -100.0
        -- y = 0.0
        -- isRight = "true"
        -- style = "wedge"
    -- }

    `codomain`.text = Text { string = `codomain`.label }
    `codomain`.nearFn = encourage nearHead(`codomain`.shape, `codomain`.text, 0.0, 20.0)
}

Set `domain`
with Set `codomain`, `domainOuter` {
    `domain`.left = Line {
        thickness = 2.0
        color = rgba(0.0, 0.0, 0.0, 1.0)
        style = "dashed"
        -- TODO: Note that using lineLeft to set 'path' (a derived property) will NOT mark startX, etc. as non-varying. Therefore, anything that depends on those properties is going to look them up in the varyMap, which is wrong.
        -- startX = `domainOuter`.shape.startX
        -- + 0.2 * (`domainOuter`.shape.endX - `domainOuter`.shape.startX)
--        startY = `domainOuter`.shape.startY
--        endX = `domainOuter`.shape.startX + 0.8 * (`domainOuter`.shape.endX - `domainOuter`.shape.startX)
--        endY = `domainOuter`.shape.endY
        -- path = lineLeft(0.2, `domainOuter`.shape, `codomain`.shape)
    }

    `domain`.right = Line {
        thickness = 2.0
        color = rgba(0.0, 0.0, 0.0, 1.0)      
        style = "dashed"
        path = lineLeft(0.8, `domainOuter`.shape, `codomain`.shape)
    }

    -- `domain`.left_label = Text { string = "A_0" }
    -- `domain`.right_label = Text { string = "A_1" }
    -- `domain`.leftFn = encourage nearEndVert(`domain`.left, `domain`.left_label)
    -- `domain`.rightFn = encourage nearEndVert(`domain`.right, `domain`.right_label)
}

Set `image`
with Set `codomain`, `domainOuter`{
    `image`.bottom = Line {
        thickness = 2.0
        color = rgba(0.0, 0.0, 0.0, 1.0)
        style = "dashed"
        path = lineRight(0.2, `codomain`.shape, `domainOuter`.shape)
    }

    `image`.top = Line {
        thickness = 2.0
        color = rgba(0.0, 0.0, 0.0, 1.0)
        style = "dashed"
        path = lineRight(0.8, `codomain`.shape, `domainOuter`.shape)
    }

    -- `image`.top_label = Text { string = "B_0" }
    -- `image`.bottom_label = Text { string = "B_1" }
    -- `image`.bottomFn = encourage nearEndHoriz(`image`.bottom, `image`.bottom_label)
    -- `image`.topFn = encourage nearEndHoriz(`image`.top, `image`.top_label)
}

-- TODO: why does resampling this curve seem to only have two kinds of shapes?

Map f
where From(f, domain, image)
with Set `domainOuter`; Set domain; Set image {
    f.shape = Curve {
        path = computeSurjectionLines(10, domain.left, domain.right, image.bottom, image.top)
        color = rgba(0.05, 0.05, 0.6, 1.0)
    }

    f.text = Text {
        string = f.label
        x = `domainOuter`.shape.endX / 2.0 - 50.0
        y = `domainOuter`.shape.endY - 30.0
    }
}

/*
Set `cartesianProduct` {
    `cartesianProduct`.shape = Rectangle {
        -- center = regionCenter(domain, image)    -- this will pass in both of domain's objects
        length = regionX(domain)
        width = regionY(image)
        color = lightBlue()
    }
}
*/
