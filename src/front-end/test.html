<!DOCTYPE html>
<html>
<head>
<title>Test SVG</title>
<script type="text/JavaScript" src="snap.svg.js"></script>
<script type="text/javascript" src="svg-path-parser-browser.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/JavaScript"
            src="https://code.jquery.com/jquery-1.6.3.min.js"></script>
 <script>
// In case the computer is not online, load local JQuery
// instead of cdn
window.jQuery || document.write('<script src=\"jquery.min.js\""><\/script>');
</script>

</head>
<body>

<h1></h1>
<p></p>

</body>
</html>

<script>
/************************** main **********************************/
// snap screen
var s = Snap(800,600);

// testing points
// var points = [[100, 100], [100,210], [210, 210], [100,100]]
// var pts = [100,100,100,210,210,210,100,100]
//var center = [(100+100+210)/3, (100+210+210)/3]
// var letterA = 'M 208 74 Q 208 50 254 46 Q 272 46 272 35 Q 272 34 270 22 Q 267 8 264 4 T 251 0 Q 249 0 239 0 T 205 1 T 141 2 Q 70 2 50 0 H 42 Q 35 7 35 11 Q 37 38 48 46 H 62 Q 132 49 164 96 Q 170 102 345 401 T 523 704 Q 530 716 547 716 H 555 H 572 Q 578 707 578 706 L 606 383 Q 634 60 636 57 Q 641 46 701 46 Q 726 46 726 36 Q 726 34 723 22 Q 720 7 718 4 T 704 0 Q 701 0 690 0 T 651 1 T 578 2 Q 484 2 455 0 H 443 Q 437 6 437 9 T 439 27 Q 443 40 445 43 L 449 46 H 469 Q 523 49 533 63 L 521 213 H 283 L 249 155 Q 208 86 208 74 Z M 516 260 Q 516 271 504 416 T 490 562 L 463 519 Q 447 492 400 412 L 310 260 L 413 259 Q 516 259 516 260 Z'
// var d='M3,7 5-6 L1,7 1e2-.4 m-10,10 l10,0  \
      // V27 89 H23           v10 h10             \
      // C33,43 38,47 43,47   c0,5 5,10 10,10     \
      // S63,67 63,67         s-10,10 10,10       \
      // Q50,50 73,57         q20,-5 0,-10        \
      // T70,40               t0,-15              \
      // A5,5 45 1,0 40,20    a5,5 20 0,1 -10-10  Z';

//drawHullPointsFromSVG(letterA, s);

var poly1 = randomPolygon();
var poly2 = randomPolygon();
drawPolygon(poly1, s)
drawPolygon(poly2, s)

/****************************************
* Given an array of Coordinate objects, draw a polygon
*****************************************/
function drawPolygon(polygon, s){
  pts = []
  count = 0
  for(var i = 0; i < polygon.length; i++){
    pts[count] = polygon[i].x
    pts[count+1] = polygon[i].y
    count += 2
  }
  // color = ["red", "blue", "green", "yellow"]
  // color[Math.floor(Math.random() * 4)]
  var randColor = Math.floor(Math.random() * 999)
  var colorStr = "#" + randColor
  console.log(randColor)
  console.log("Array of points to send to snap polyline function: ")
  console.log(pts)
  var p = s.polyline(pts)
  p.attr({
    fill: colorStr,
		stroke: "black",
		strokeWidth: 2
  })
}


/*************************************
* Creates random polygon points
**************************************/
function randomPolygon(){
  var xCenter = Math.floor(Math.random() * 300) + 100;
  var yCenter = Math.floor(Math.random() * 300) + 100;
  var rmax = 100, rmin =20;
  var pointmax = 10, pointmin = 3;
  var numPoints = Math.floor(Math.random() * (pointmax-pointmin)) + pointmin;

  console.log("Center: " + xCenter + " " + yCenter);
  console.log("numPoints is " + numPoints);

  poly = []
  for(var i = 0; i < numPoints; i++){
    var pt = {}
    var r = Math.floor(Math.random() * (rmax-rmin)) + rmin;
    // console.log("R at " + i + " is " + r);
    pt.x = Math.floor(xCenter + r * Math.cos(2 * Math.PI * i / numPoints))
    pt.y = Math.floor(yCenter + r * Math.sin(2 * Math.PI * i / numPoints));
    poly.push(pt)
  }
  var end = {}
  end.x = poly[0].x
  end.y = poly[0].y
  poly.push(end)

  return poly
}

/*************************************
* Draws a polygon from an SVG by taking all points along the hull of a polygon
**************************************/
function drawHullPointsFromSVG(inputSVG, s){
  newpoints = []
  count = 0;
  parsedSVG = parsePathString(inputSVG)
  for (var i in parsedSVG) {
  	if (parsedSVG[i].code === 'Q' || parsedSVG[i].code === 'M' || parsedSVG[i].code === 'C'	|| parsedSVG[i].code === 'L' || parsedSVG[i].code === 'T'){
  		newpoints[count] = parsedSVG[i].x
  		newpoints[count+1] = parsedSVG[i].y
  		count+=2
  	}
  	else if (parsedSVG[i].code === 'H'){
  		newpoints[count] = parsedSVG[i].x
  		newpoints[count+1] = newpoints[count-1]
  		count+=2
  	}
  	else if (parsedSVG[i].code === 'V'){
  		newpoints[count] = newpoints[count-1]
  		newpoints[count+1] = parsedSVG[i].y
  		count+=2
  	}
  	else if (parsedSVG[i].code === 'Z'){ //TWO NEGATIVE numbers means there is a break in the polgon
  		newpoints[count] = newpoints[0]    //similar to "pick up pen, move, put down pen"
  		newpoints[count+1] = newpoints[1]
  		newpoints[count+2] = -1           //negative numbers are placeholders for "pen up"
  		newpoints[count+3] = -1
  		count+=4
  	}
  	//TODO add in A elliptical
  	else
  		count = count
  }
  return newpoints
}

/*************************************
* Draws a polygon whose points have been scaled up by user specified size
**************************************/
function drawScaled(points, center, size){
	var newpoints = []
	for (var i = 0; i < points.length; i++) {
		time = i%2
		newpoints[i] = (points[i] -center[time]) * size + center[time];
	}
	var polyline = s.polyline(newpoints)
	polyline.attr({
		fill: "none",
		stroke: "#000",
		strokeWidth: 2
	})
}

/*************************************
* scales points in a polygon, not around a center
**************************************/
// function scale(points, ratio){
// 	for (var i in points){
// 		if (points[i] != 0)
// 			points[i] = points[i] * ratio;
// 	}
// 	return points
// }

/*************************************
* Uses a cubic bezier equation to evaluate a curve at n points
**************************************/
function bezier3(list, n){
  //var curve = s.path(list)
  // curve.attr({
  // 	fill: "none",
  // 	stroke: "#000",
  // 	strokeWidth: 2
  // })
	var pts = []
	var x, y
	for(var i = 0; i <= n; i++){
		t = i/n
		ot = 1-t
		p0 = list[0]
		p1 = list[1]
		p2 = list[2]
		x =  ot* (ot*p0[0] + t*p1[0]) + t*(ot*p1[0] + t*p2[0])
		y =  ot* (ot*p0[1] + t*p1[1]) + t*(ot*p1[1] + t*p2[1])
		pts.push(x)
		pts.push(y)
	}
	return pts
}

/*************************************
* a funciton that tests bezier3 with an example point set
**************************************/
function drawTestPolygonized3Bezier(){
  var points = [[100, 100], [100,210], [210, 210], [100,100]]
  var n = 10 // the amount of control points wanted along the curve
  var bez = bezier3(points, n)
  var p = s.polyline(bez)
  p.attr({
  		fill: "none",
  		stroke: "#000",
  		strokeWidth: 2
  	})
  var p = []
  p[0] = s.circle(points[0][0], points[0][1], 5)
  p[1] = s.circle(points[1][0], points[1][1], 5)
  p[2] = s.circle(points[2][0], points[2][1], 5)
  for (var i = 0; i < p.length; i++) {
  	p[i].attr({
  		fill: "#fc0",
  		stroke: "#000",
  		strokeWidth: 2
  	})
  }
}



</script>
