global {
  global.padding = 10.0
}

origin {
  origin.x = -200.0
  origin.y = 100.0
}

Colors {
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.gray = rgba(0.8, 0.8, 0.8, 1.0)
    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.pink = rgba(1.0, 0.4, 0.7, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    Colors.lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.sky = rgba(0.325, 0.718, 0.769, 1.0)
    Colors.lightsky = rgba(0.325, 0.718, 0.769, 0.25)
    Colors.lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    Colors.cyan = rgba(0.0, 1.0, 1.0, 1.0)
    Colors.purple = rgba(0.5, 0.0, 0.5, 1.0)
    Colors.white = rgba(1.0, 1.0, 1.0, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
    Colors.lightblue2 = rgba(0.82, 0.88, 0.94, 1.0)
    Colors.lightpink = rgba(0.9, 0.5, 0.5, 0.25)
}

-- Should there be a style for generic Interval
-- without a Subset relationship?
-- It would specify the fields that the subtypes
-- would need to have, like left, right, yval, shape

Reals `R` {
  R.len = 500.0
  R.thickness = 1.5
  R.color = Colors.gray

  R.left = origin.x
  R.right = origin.x + R.len
  R.yval = origin.y

  R.shape = Arrow {
    startX = R.left
    startY = R.yval
    endX = R.right
    endY = R.yval
    thickness = R.thickness
    color = R.color
    rotation = 0.0
  }

  R.text = Text {
    string = R.label
    rotation = 0.0
  }

  R.labelFn = ensure nearHead(R.shape, R.text, global.padding, global.padding)
}

Real r  -- no "In(r, `R`)"
with Reals `R` {
  r.val = OPTIMIZED
  r.yval = `R`.yval
  r.len = 20.0

  r.shape = Line {
    startX = r.val
    startY = r.yval - (r.len / 2.0)
    endX = r.val
    endY = r.yval + (r.len / 2.0)
    thickness = 2.5
    color = Colors.black
  }

  r.text = Text {
    string = r.label
    rotation = 0.0
  }

  r.inFn = ensure inRange(r.val, R.left, R.right)
  r.labelFn = encourage nearHead(r.shape, r.text, 10.0, 10.0)
}

----------------------------------
-- INTERVAL STYLES

Interval I
where Subset(I, R)
with Reals R { -- TODO: more general, with Interval J
  I.left = OPTIMIZED
  I.right = OPTIMIZED
  I.yval = R.yval

  I.shape = Line { -- horizontal
    startX = I.left
    startY = I.yval
    endX = I.right
    endY = I.yval
    thickness = 7.5
    color = rgba(0.3, 0.3, 0.9, 0.5)
  }

  -- position computed, not optimized
  I.text = Text {
    string = I.label
    x = (I.shape.endX + I.shape.startX) / 2.0
    y = I.yval + global.padding
    rotation = 0.0
  }

  I.wfFn = ensure lessThan(I.left, I.right)
  I.liFn = ensure inRange(I.left, R.left, R.right)
  I.riFn = ensure inRange(I.right, R.left, R.right)

  -- TODO: the first I.labelFn interferes with I.wfFn
  -- I.labelFn = encourage centerLabel(I.shape, I.text)
  -- I.labelFn = ensure inRange(I.text.x, a.val, b.val)
  -- I.labelFn = encourage nearHead(I.shape, I.text, 0.0, 10.0)
}

Real a; Real b
with Interval I; Reals R
where I := CreateInterval(a, b); Subset(I, R) {
  override a.val = I.left
  override b.val = I.right
  override a.yval = I.yval
  override b.yval = I.yval
  -- I.left and I.right already have I.liFn, I.riFn
  delete a.inFn
  delete b.inFn
}

Real r
with Interval I; Reals R; Real a; Real b
where I := CreateInterval(a, b); In(r, I); Subset(I, R) {
  override r.yval = I.yval
  override r.inFn = ensure inRange(r.val, a.val, b.val)
  override r.shape.color = Colors.red
}

Real a; Real b
with OpenInterval I; Reals R
where I := CreateOpenInterval(a, b); Subset(I, R) {
  override a.shape = Image {
      path = "left-paren.svg"
      centerX = a.val
      centerY = a.yval
      lengthX = 10.0
      lengthY = 20.0
  }

  override b.shape = Image {
      path = "right-paren.svg"
      centerX = b.val
      centerY = b.yval
      lengthX = 10.0
      lengthY = 20.0
  }

    override a.labelFn = encourage near(a.shape, a.text, 0.0, -20.0)
    override b.labelFn = encourage near(b.shape, b.text, 0.0, -20.0)
}

Real a; Real b
with ClosedInterval I; Reals R
where I := CreateClosedInterval(a, b); Subset(I, R) {
  override a.shape = Image {
      path = "left-bracket.svg"
      centerX = a.val
      centerY = a.yval
      lengthX = 10.0
      lengthY = 20.0
  }

  override b.shape = Image {
      path = "right-bracket.svg"
      centerX = b.val
      centerY = b.yval
      lengthX = 10.0
      lengthY = 20.0
  }

    override a.labelFn = encourage near(a.shape, a.text, 0.0, -20.0)
    override b.labelFn = encourage near(b.shape, b.text, 0.0, -20.0)
}

Real a; Real b
with LeftClopenInterval I; Reals R
where I := CreateLeftClopenInterval(a, b); Subset(I, R) {
  override a.shape = Image {
      path = "left-bracket.svg"
      centerX = a.val
      centerY = a.yval
      lengthX = 10.0
      lengthY = 20.0
  }

  override b.shape = Image {
      path = "right-paren.svg"
      centerX = b.val
      centerY = b.yval
      lengthX = 10.0
      lengthY = 20.0
  }

    override a.labelFn = encourage near(a.shape, a.text, 0.0, -20.0)
    override b.labelFn = encourage near(b.shape, b.text, 0.0, -20.0)
}

Real a; Real b
with RightClopenInterval I; Reals R
where I := CreateRightClopenInterval(a, b); Subset(I, R) {
  override a.shape = Image {
      path = "left-paren.svg"
      centerX = a.val
      centerY = a.yval
      lengthX = 10.0
      lengthY = 20.0
  }

  override b.shape = Image {
      path = "right-bracket.svg"
      centerX = b.val
      centerY = b.yval
      lengthX = 10.0
      lengthY = 20.0
  }

    override a.labelFn = encourage near(a.shape, a.text, 0.0, -20.0)
    override b.labelFn = encourage near(b.shape, b.text, 0.0, -20.0)
}

----------------------------------
-- FUNCTION STYLES

/* The selectors for drawing a single function
cascade by first drawing a generic function between two *different* intervals (where Real is a subtype of Interval), drawing a new Real line and setting the relevant pointers. The selectors after it deal with the following specific cases:

- if f : R -> R, set f's domain and codomain accordingly
- if f : (R or I) -> J (where J is an interval that's a subset of R), move J onto the second real number line
- if f : I -> R, f's codomain needs to be the second real number line, otherwise f will be drawn to map onto the first real number line (which is a valid visualization style, just confusing to see)

We currently do not draw f : I -> I. */

/* f : I -> J
 If there is any function from I to J, then we make a second real number line that those functions all share. (This is going to be done for every match, hence the `override` / lack of `override` warnings.) This will achieve the effect of if only one shape had been made. 

TODO: Doesn't match f : R -> R right now but will match if we add a "could equal" for I ?= J */

Function f
with Interval I; Interval J; Reals `R`
-- Does NOT match with generic "Reals R"!
where f := CreateFunction(I, J) {
  `R`.yval2 = `R`.yval - 100.0 -- function drawn downward

  `R`.shape2 = Arrow {
    startX = `R`.left
    startY = `R`.yval2
    endX = `R`.right
    endY = `R`.yval2
    thickness = `R`.thickness
    color = `R`.color
    rotation = 0.0
  }

 `R`.shape2_text = Text {
    string = `R`.label
    rotation = 0.0
  }

  `R`.shape2_labelFn = ensure nearHead(`R`.shape2, `R`.shape2_text, global.padding, global.padding)

  -------------------------------------------------

  f.val = OPTIMIZED   -- placeholder, TODO sample f's value
  f.domain = I.shape -- TODO: we really want to be able to write `f.domain = I` but it doesn't even parse
  f.codomain = J.shape

  f.shape = Curve {
    pathData = sampleFunctionArea(f.domain, f.codomain, 5.0, 30.0)
    strokeWidth = 0.0
    fill = Colors.lightpink
    color = Colors.lightpink
    rotation = 0.0
  }

  f.text = Text {
    string = f.label
    x = average(midpointX(f.domain), midpointX(f.codomain)) + 10.0
    y = average(f.domain.startY, f.codomain.startY)
    rotation = 0.0
  }
}

-- This is simply copy-pasted from the previous selector except for f.domain and f.codomain
-- Not sure how to make it more generic, since we do want to do something special for f : I -> I

Function f
with Reals `R`
where f := CreateFunction(`R`, `R`) {
  `R`.yval2 = `R`.yval - 100.0 -- function drawn downward

  `R`.shape2 = Arrow {
    startX = `R`.left
    startY = `R`.yval2
    endX = `R`.right
    endY = `R`.yval2
    thickness = `R`.thickness
    color = `R`.color
    rotation = 0.0
  }

 `R`.shape2_text = Text {
    string = `R`.label
    rotation = 0.0
  }

  `R`.shape2_labelFn = ensure nearHead(`R`.shape2, `R`.shape2_text, global.padding, global.padding)

  -------------------------------------------------

  f.val = OPTIMIZED
  f.domain = `R`.shape
  f.codomain = `R`.shape2

  f.shape = Curve {
    pathData = sampleFunctionArea(f.domain, f.codomain, 5.0, 30.0)
    strokeWidth = 0.0
    fill = Colors.lightpink
    color = Colors.lightpink
    rotation = 0.0
  }

  f.text = Text {
    string = f.label
    x = average(midpointX(f.domain), midpointX(f.codomain)) + 10.0
    y = average(f.domain.startY, f.codomain.startY)
    rotation = 0.0
  }
}

/* We have no style for f : I -> I where I is a generic interval in R.  Hard to visualize with the "mass" function. ut we could easily draw a loopy arrow. */

Function f
with Interval I; Interval J; Reals `R`
where f := CreateFunction(I, J);
      Subset(J, `R`) { -- i.e. J is not of type Reals

  override J.yval = `R`.yval2
  -- avoid cycles if I=R in generic (I,J) selector
}

Function f
with Interval I; Reals R
where f := CreateFunction(I, R) {

  override f.codomain = R.shape2
  -- specifically draw from the current R to new R
  -- otherwise, will show it from R to itself
  -- (which is also a valid viz)
}

/*
Function `g` {
	 override `g`.shape.fill = Colors.lightsky
	 override `g`.shape.color = Colors.lightsky
} */

/* h = g . f

If there is a composition of functions, draw a third R for the second function. Again, this is technically going to be made for every match, but overridden to be the same thing. (Does NOT deal with composition of 3 functions, i = h . g . f) */

Function h, g, f
where h := compose(g, f);
      h := CreateFunction(A, C);
      g := CreateFunction(B, C);
      f := CreateFunction(A, B)
      -- disallow equality for simplicity
      -- TODO: deal with these later
      -- A ?= B; B ?= C; h ?= g; g ?= f
with Interval A, B, C;
     Reals `R` {
  `R`.yval3 = `R`.yval2 - 100.0 -- function drawn downward

  `R`.shape3 = Arrow {
    startX = `R`.left
    startY = `R`.yval3
    endX = `R`.right
    endY = `R`.yval3
    thickness = `R`.thickness
    color = `R`.color
    rotation = 0.0
  }

 `R`.shape3_text = Text {
    string = `R`.label
    rotation = 0.0
  }

  `R`.shape3_labelFn = ensure nearHead(`R`.shape3, `R`.shape3_text, global.padding, global.padding)

  -------------------------------------------------

  -- move g's codomain to the new real line
  -- have to use C because we can't write
  -- "f.codomain = J" in the function block yet
  override C.yval = `R`.yval3

  -- TODO: not sure why the "handles" of g are high
  -- they look like the "handles" of f?
  -- this line changes the y offset of the midpts
  -- but it shouldn't be necessary
  override g.shape.pathData = sampleFunctionArea(g.domain, g.codomain, 5.0, -30.0)

  -- delete h's shape, label, etc.
  delete h.val
  delete h.shape
  delete h.text
}

/* Composition of a composition of functions 
   Two cases:
   Composition on the left
   Composition on the right */

-- Composition on the right
-- Note that the first function composition
-- selector will apply first, and this will cascade

/* TODO: WHY is this slowing down the Style compiler? Way too many matches on the selector (WRT the cartesian product and filtering)?
And why is it slowing down the generation of the translation?
And why does it take so long to render on the server?
It doesn't seem to be generating an unusual number of objects.
And interactions on the server take a lot of time--must be the translation being slow? large? 
Should there be that many Style warnings?
Maybe the previous composition selector is matching too many times?
Maybe evaluating the translation somehow means having to lazily redo the match?
*/

Function h
where h := compose(g, f);
      f := compose(e, d);
      -- It's a little faster with the intervals and createFunctions commented out.
      h := CreateFunction(A, D)
      -- g := CreateFunction(C, D);
      -- f := CreateFunction(A, C);
      -- e := CreateFunction(B, C);
      -- d := CreateFunction(A, B)
with Function g, f, e, d;
     Interval A, D;
     Reals `R` {
     -- Interval A, B, C, D;

     -- just to test the match
     -- override `R`.shape3.color = Colors.red

  `R`.yval4 = `R`.yval3 - 100.0 -- function drawn downward

  `R`.shape4 = Arrow {
    startX = `R`.left
    startY = `R`.yval4
    endX = `R`.right
    endY = `R`.yval4
    thickness = `R`.thickness
    color = `R`.color
    rotation = 0.0
  }

 `R`.shape4_text = Text {
    string = `R`.label
    rotation = 0.0
  }

  `R`.shape4_labelFn = ensure nearHead(`R`.shape4, `R`.shape4_text, global.padding, global.padding)

  -------------------------------------------------

  -- move g's codomain to the new real line
  -- have to use C because we can't write
  -- "f.codomain = J" in the function block yet
  override D.yval = `R`.yval4

  -- TODO: not sure why the "handles" of g are high
  override g.shape.pathData = sampleFunctionArea(g.domain, g.codomain, 5.0, -60.0)

  -- delete h's shape, label, etc.
  delete h.val
  delete h.shape
  delete h.text
}

----------------------------------
-- FUNCTION APPLICATION STYLES

-- y := f(x)
Real y; Function f
with Interval I; Interval J; Real x; Reals R
where y := apply(f, x); f := CreateFunction(I, J); In(x, I) {

  -- so it's not necessary to say In(y, J)
  override y.yval = J.yval

  f.pointwise_shape = Curve {
    -- TODO: syntax for working with 2-tuples and lists
    -- TODO: why does this not interpolate properly with offset = (0, 0)?
    -- TODO: more curves = more time to optimize?
    pathData = makeCurve(x.val, I.yval - 2.0 * global.padding, y.val, J.yval + 2.0 * global.padding, -10.0, -(J.yval - I.yval) / 1.5)
    strokeWidth = 2.0
    fill = Colors.none
    color = Colors.sky
    rotation = 0.0
    -- TODO: rename to account for arrow directionality
    right-arrowhead = True
  }
}