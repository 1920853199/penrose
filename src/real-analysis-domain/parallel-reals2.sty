global {
  global.padding = 10.0
}

origin {
  origin.x = -200.0
  origin.y = 100.0
}

Colors {
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.gray = rgba(0.8, 0.8, 0.8, 1.0)
    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.pink = rgba(1.0, 0.4, 0.7, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    Colors.lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.sky = rgba(0.325, 0.718, 0.769, 1.0)
    Colors.lightsky = rgba(0.325, 0.718, 0.769, 0.25)
    Colors.lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    Colors.cyan = rgba(0.0, 1.0, 1.0, 1.0)
    Colors.purple = rgba(0.5, 0.0, 0.5, 1.0)
    Colors.white = rgba(1.0, 1.0, 1.0, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
    Colors.lightblue2 = rgba(0.82, 0.88, 0.94, 1.0)
    Colors.lightpink = rgba(0.9, 0.5, 0.5, 0.25)
}

Reals `R` {
  R.len = 500.0
  R.thickness = 1.5
  R.color = Colors.gray

  R.left = origin.x
  R.right = origin.x + R.len
  R.yval = origin.y

  R.shape = Arrow {
    startX = R.left
    startY = R.yval
    endX = R.right
    endY = R.yval
    thickness = R.thickness
    color = R.color
    rotation = 0.0
  }

  R.text = Text {
    string = R.label
    rotation = 0.0
  }

  R.labelFn = ensure nearHead(R.shape, R.text, global.padding, global.padding)
}

Real r  -- no "In(r, `R`)"
with Reals `R` {
  r.val = OPTIMIZED
  r.yval = `R`.yval
  r.len = 20.0

  r.shape = Line {
    startX = r.val
    startY = r.yval - (r.len / 2.0)
    endX = r.val
    endY = r.yval + (r.len / 2.0)
    thickness = 2.5
    color = Colors.black
  }

  r.text = Text {
    string = r.label
    rotation = 0.0
  }

  r.inFn = ensure inRange(r.val, R.left, R.right)
  r.labelFn = encourage nearHead(r.shape, r.text, 10.0, 10.0)
}

----------------------------------
-- INTERVAL STYLES

-- TODO: Implement subtyping match WRT value ctors
-- so the next 3 selectors can apply generically to intervals.

Interval I
where Subset(I, R)
with Reals R { -- TODO: more general, with Interval J
  I.left = OPTIMIZED
  I.right = OPTIMIZED
  I.yval = R.yval

  I.shape = Line { -- horizontal
    startX = I.left
    startY = I.yval
    endX = I.right
    endY = I.yval
    thickness = 7.5
    color = rgba(0.3, 0.3, 0.9, 0.5)
  }

  -- position computed, not optimized
  I.text = Text {
    string = I.label
    -- TODO: This doesn't seem to be computed properly
    -- x = (I.shape.endX - I.shape.startX) / 2.0
    y = I.yval + global.padding
    rotation = 0.0
  }

  I.wfFn = ensure lessThan(I.left, I.right)
  I.liFn = ensure inRange(I.left, R.left, R.right)
  I.riFn = ensure inRange(I.right, R.left, R.right)
  I.labelFn = encourage centerLabel(I.shape, I.text)
  -- I.labelFn = ensure inRange(I.text.x, a.val, b.val)
  -- I.labelFn = encourage nearHead(I.shape, I.text, 0.0, 10.0)
}

Real a; Real b
with Interval I; Reals R
where I := CreateInterval(a, b); Subset(I, R) {
  override a.val = I.left
  override b.val = I.right
}

Real r
with Interval I; Reals R; Real a; Real b
where I := CreateInterval(a, b); In(r, I); Subset(I, R) {
  override r.yval = I.yval
  override r.inFn = ensure inRange(r.val, a.val, b.val)
  override r.shape.color = Colors.red
}

Real a; Real b
with OpenInterval I; Reals R
where I := CreateOpenInterval(a, b); Subset(I, R) {
  -- TODO: next 2 lines are duplicated from interval style; remove

  override a.val = I.left
  override b.val = I.right
  override a.yval = I.yval
  override b.yval = I.yval

  -- lines copied from real-analysis-types.sty
  override a.shape = Image {
      path = "left-paren.svg"
      centerX = a.val
      centerY = a.yval
      lengthX = 10.0
      lengthY = 20.0
  }

  override b.shape = Image {
      path = "right-paren.svg"
      centerX = b.val
      centerY = b.yval
      lengthX = 10.0
      lengthY = 20.0
  }

    override a.labelFn = encourage near(a.shape, a.text, 0.0, -20.0)
    override b.labelFn = encourage near(b.shape, b.text, 0.0, -20.0)
}

-- TODO: duplicated from Interval; remove
-- also TODO: missing one for ClosedInterval
Real r
with OpenInterval I; Reals R; Real a; Real b
where I := CreateOpenInterval(a, b); In(r, I); Subset(I, R) {
  override r.yval = I.yval
  override r.inFn = ensure inRange(r.val, a.val, b.val)
  override r.shape.color = Colors.red
}

Real a; Real b
with ClosedInterval I; Reals R
where I := CreateClosedInterval(a, b); Subset(I, R) {
  -- TODO: next 2 lines are duplicated from interval style; remove

  override a.val = I.left
  override b.val = I.right
  override a.yval = I.yval
  override b.yval = I.yval

  -- lines copied from real-analysis-types.sty
  override a.shape = Image {
      path = "left-bracket.svg"
      centerX = a.val
      centerY = a.yval
      lengthX = 10.0
      lengthY = 20.0
  }

  override b.shape = Image {
      path = "right-bracket.svg"
      centerX = b.val
      centerY = b.yval
      lengthX = 10.0
      lengthY = 20.0
  }

    override a.labelFn = encourage near(a.shape, a.text, 0.0, -20.0)
    override b.labelFn = encourage near(b.shape, b.text, 0.0, -20.0)
}

----------------------------------
-- FUNCTION STYLES

-- f : I -> R
-- If there is any function from I to R, then we make a
-- second real number line that those functions all share.
-- (This is going to be done for every match, hence the
-- `override` / lack of `override` warnings.)
-- Will achieve the effect of if only one shape had been made

Function f; Reals R
with Interval I; Interval J
where f := CreateFunction(I, J) {
  R.yval2 = R.yval - 100.0 -- function drawn downward

  R.shape2 = Arrow {
    startX = R.left
    startY = R.yval2
    endX = R.right
    endY = R.yval2
    thickness = R.thickness
    color = R.color
    rotation = 0.0
  }

 R.shape2_text = Text {
    string = R.label
    rotation = 0.0
  }

  R.shape2_labelFn = ensure nearHead(R.shape2, R.shape2_text, global.padding, global.padding)

  override J.yval = R.yval2
  -------------------------------------------------
  -- draw f as an arrow from interval to reals
  f.val = OPTIMIZED   -- placeholder, TODO sample f's value
  f.domain = I.shape
  f.codomain = J.shape

  /* f.shape = Arrow {
    startX = midpointX(f.domain)
    startY = I.yval - global.padding
    endX   = midpointX(f.codomain)
    endY   = R.yval2 + global.padding
    thickness = R.thickness * 2.0
    -- color = Colors.blue
    rotation = 0.0
  } */

  f.shape = Curve {
    pathData = sampleFunctionArea(I.shape, J.shape, 5.0, 30.0)
    strokeWidth = 0.0
    fill = Colors.lightpink
    color = Colors.lightpink
    rotation = 0.0
  }

  f.text = Text {
    string = f.label
    rotation = 0.0
  }

  f.text.x = average(midpointX(I.shape), midpointX(J.shape)) + 10.0
  f.text.y = average(I.yval, J.yval)

  -- f.labelFn = encourage centerLabel(f.shape, f.text)
}

-- h = g . f
-- If there is a composition of functions, draw a third R for the second function
  -- again, this is technically going to be made for every match, but overridden to be the same thing
-- (Does NOT deal with composition of 3 functions, i = h.g.f)

Function `g` {
	 override `g`.shape.fill = Colors.lightsky
	 override `g`.shape.color = Colors.lightsky
}

Function h;
Function g;
Function f
where h := compose(g, f);
      h := CreateFunction(A, R);
      g := CreateFunction(B, R);
      f := CreateFunction(A, B)
      -- disallow equality for simplicity
      -- TODO: deal with these later
      -- A ?= B; B ?= C; h ?= g; g ?= f
      -- TODO: generalize the selector to three intervals
with Interval A, B;
     Reals R
{
  R.yval3 = R.yval2 - 100.0 -- function drawn downward

  R.shape3 = Arrow {
    startX = R.left
    startY = R.yval3
    endX = R.right
    endY = R.yval3
    thickness = R.thickness
    color = R.color
    rotation = 0.0
  }

 R.shape3_text = Text {
    string = R.label
    rotation = 0.0
  }

  R.shape3_labelFn = ensure nearHead(R.shape3, R.shape3_text, global.padding, global.padding)

  -------------------------------------------------
  -- move B to be in f's codomain
  -- B matches J
  -- may not work in general; specialized to our case
  -- TODO: work out how it generalizes
  override B.yval = R.yval2

  -- update f to point to J
  -- TODO: this should match the `f(I) \subset J` in Sub
  override f.codomain = B.shape
  override f.shape.endX = midpointX(B.shape)

  -- move g's codomain to be the third R
  override g.codomain = R.shape3
  override g.shape.endY = R.yval3 + global.padding

  override h.codomain = R.shape3
  -- delete h's shape, label, etc.
  delete h.val
  delete h.shape
  delete h.text
  delete h.labelFn
}

-- TODO: selectors to make fourth, fifth, etc. R
-- specifically for the composition of three, four functions

----------------------------------
-- FUNCTION APPLICATION STYLES

-- y := f(x)
Real y; Function f
with Interval I; Interval J; Real x; Reals R
where y := apply(f, x); f := CreateFunction(I, J); In(x, I) {

  -- so it's not necessary to say In(y, J)
  override y.yval = J.yval

  f.pointwise_shape = Curve {
    -- TODO: syntax for working with 2-tuples and lists
    pathData = makeCurve(x.val, I.yval, y.val, J.yval, 0.0, 0.0)
    strokeWidth = 2.0
    fill = Colors.sky
    color = Colors.sky
    rotation = 0.0
    -- TODO: rename to account for arrow directionality
    right-arrowhead = True
  }

/* f.pointwise_shape = Arrow {
    startX = x.val
    startY = I.yval - global.padding
    endX   = y.val
    endY   = J.yval + global.padding
    thickness = R.thickness
    color = f.shape.color
    rotation = 0.0
  } */

}