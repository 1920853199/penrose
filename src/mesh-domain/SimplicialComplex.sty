plugin "ddgjs"

global {
    global.padding = 20.0
    global.stroke = 2.0
    global.selectedColor = Colors.red
    global.selectedColor2 = setOpacity(global.selectedColor, 0.25)
    global.subsetColor = Colors.purple
    global.subsetColor2 = setOpacity(global.subsetColor, 0.25)
}

Colors {
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.darkgray = rgba(0.1, 0.1, 0.1, 1.0)
    Colors.gray = rgba(0.8, 0.8, 0.8, 1.0)
    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.pink = rgba(1.0, 0.4, 0.7, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    Colors.lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.sky = rgba(0.325, 0.718, 0.769, 1.0)
    Colors.lightsky = rgba(0.325, 0.718, 0.769, 0.25)
    Colors.lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    Colors.cyan = rgba(0.0, 1.0, 1.0, 1.0)
    Colors.purple = rgba(0.5, 0.0, 0.5, 1.0)
    Colors.lightpurple = rgba(0.5, 0.0, 0.5, 0.25)
    Colors.white = rgba(1.0, 1.0, 1.0, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
    Colors.bluegreen = rgba(0.44, 0.68, 0.60, 1.0)
}

Vertex v {
       v.shape = Circle { 
         r = 6.0
	 color = Colors.black	 
	 strokeWidth = 0.0
       }

       v.text = Text {
	 x = v.shape.x + global.padding
	 y = v.shape.y + global.padding
	 string = v.label
	 rotation = 0.0
	 color = v.shape.color
       }
}

-- Is this going to match too many times?
-- It'll match once for (e, v1, v2) and again for (e, v2, v1), because it's not ordered, as opposed to e := MkEdge(v1, v2), which can only match once
Edge e
where InVE(v1, e); InVE(v2, e)
-- where e := Mkedge(v1, v2)
with Vertex v1; Vertex v2 {
     e.shape = Line { 
     	     startX = v1.shape.x
     	     startY = v1.shape.y
     	     endX = v2.shape.x
     	     endY = v2.shape.y
	     color = Colors.black
	     thickness = 3.0
     }

     e.text = Text {
       x = midpointX(e.shape) + global.padding
       y = midpointY(e.shape) + global.padding
       string = e.label
       rotation = 0.0
     }

     e.layering1 = v1.shape above e.shape
     e.layering2 = v2.shape above e.shape
}

Face f
where f := MkFace(e1, e2, e3)
with Edge e1; Edge e2; Edge e3 {
     f.color = Colors.lightsky

     f.shape = Curve { 
     	     pathData = triangle(e1.shape, e2.shape, e3.shape)
	     strokeWidth = 0.0
	     fill = Colors.none
	     color = Colors.none
	     rotation = 0.0
     }

     -- f.text = Text {
     --   string = f.label
     --   color = f.color
     --   rotation = 0.0
     -- }
}

------------------ Things in a subset

Vertex v
where InVS(v, s)
with SSubset s {
      override v.shape.color = global.subsetColor
}

Edge e
where InES(e, s)
with SSubset s {
      override e.shape.color = global.subsetColor
}

Face f
where InFS(f, s)
with SSubset s {
      override f.shape.fill = global.subsetColor2
      override f.shape.color = global.subsetColor2
}

------------------- Selected things

Vertex v
where SelectedV(v) {
      override v.shape.color = global.selectedColor
}

Edge e
where SelectedE(e) {
      override e.shape.color = global.selectedColor
}

Face f
where SelectedF(f) {
      override f.shape.fill = global.selectedColor2
      override f.shape.color = global.selectedColor2
}

/*
SimplicialSet S 
{
	-- label the closure
}

SimplicialComplex K
with ?? -- Need to pull in a list of things?
where In(v, K), In(f, K)
{
	-- draw a box around the simplicial complex and everything in it
	-- label the box corner
}
*/