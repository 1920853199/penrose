-- REVISED

import module Colors

-- Global constants and sizes
const { -- Since it's a namespace, can implicitly refer to members like `const.barSize`
  float lineThickness = 1.5
  float strokeWidth = 2.0
}

forall VectorSpace U {               -- LinearAlgebra.sty
   float axisSize = 1.0 -- This is a local var
   vec2 U.origin = (?, ?) -- This is a globally-accessible var
   
   shape U.xAxis = Arrow { -- draw an arrow along the x-axis 
          start : (U.origin.x - axisSize, U.origin.y)
          end   : (U.origin.x + axisSize, U.origin.y)
      thickness   : const.lineThickness
          style   : "solid"
          color   : Colors.lightGray 
   } -- (similar declarations omitted for the y-axis)
}

forall Vector u, VectorSpace U -- match any vector
where In(u, U) {             -- in some vector space
   shape u.arrow = Arrow { 
      start : U.origin
        end : (?, ?)  
      color : Colors.mediumBlue
   }
   
   shape u.text = Text {
        string : u.label -- label from Substance code
         color : u.arrow.color  -- use arrow's color
        center : (?, ?)
   }

-- Local vars
   vec2 u.start = u.arrow.start
   vec2 u.end = u.arrow.end
   vec2 u.vector = u.arrow.end - u.arrow.start
   encourage near(u.text, u.end) 
   ensure contained(u.end, U.shape)
}

forall Vector u, Vector v 
where Orthogonal(u, v) { 
   local.perpMark = Curve { 
        pathData : orientedSquare(u.shape, v.shape, 
                                  U.origin, const.perpLen)
        strokeWidth : const.strokeWidth
        color : Colors.black
        fill : Colors.white
   } 
     ensure equals(dot(u.vector, v.vector), 0.0) 
}

... -- (similar rule omitted for Unit)

Vector `x2`  {
   override `x2`.shape.color = Colors.green; 
}

-- Local functions. Written in typescript; Looks very similar to Computations.ts
functions = {

  // Shape type is [string, any] <-- type, then props
  orientedSquare: (arr1: any, arr2: any, pt: any, len: number) => {

    // Can still log, etc for debugging
    console.log("orientedSquare", arr1, arr2, pt, len);

    // Need to build up path -- this is just a placeholder, not the actual math
    const elems = [{ tag: "Pt", contents: [100, 100].map(varAD) },
    { tag: "Pt", contents: [200, 200].map(varAD) },
    { tag: "Pt", contents: [300, 150].map(varAD) }];
    const path = { tag: "Open", contents: elems };


    // Need to tag return type
    return { tag: "PathDataV", contents: [path] };
  },

}