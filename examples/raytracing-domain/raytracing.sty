plugin "regexExpander" (200.0, 200.0)

global { 
    global.padding = 10 
    global.CANVAS_WIDTH = 200.0
    global.CANVAS_HEIGHT = 200.0
}


Colors {
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.gray = rgba(0.8, 0.8, 0.8, 1.0)
    Colors.darkgray = rgba(0.6, 0.6, 0.6, 1.0)
    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.lightKhaki = rgba(0.941, 0.902, 0.549, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    Colors.lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    Colors.cyan = rgba(0.0, 1.0, 1.0, 1.0)
    Colors.purple = rgba(0.5, 0.0, 0.5, 1.0)
    Colors.white = rgba(1.0, 1.0, 1.0, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
    Colors.sky = rgba(0.42, 0.65, 0.77, 1.0)
    Colors.lightsky = rgba(0.252, 0.65, 0.77, 0.25)
    Colors.pink = rgba(0.78, 0.256, 0.53, 1.0)
    Colors.lightpink = rgba(0.78, 0.256, 0.53, 0.25)
    Colors.bluegreen = rgba(0.44, 0.68, 0.60, 1.0)
}

Scene s {
    -- ? fields to be shared with diffuse obj
    s.x = ?
    s.y = ?
    -- s.sizeX = ?
    -- s.sizeY = ?
    s.sizeX = global.CANVAS_WIDTH
    s.sizeY = global.CANVAS_HEIGHT

    s.container = Rectangle {
        x : s.x
        y : s.y
        sizeX : s.sizeX
        sizeY : s.sizeY
        color   : Colors.none
        strokeColor : Colors.black
        strokeWidth : 1.5
    }
    s.minSizeFn = ensure minSize(s.container)
    s.maxSizeFn = ensure maxSize(s.container)
}

DiffuseObject d
where InOS(d, s) with Scene s {
    d.shape = Rectangle {
        angle  : 0
        color   : Colors.none
        strokeColor : Colors.black
        strokeWidth : 1.5
        -- optimize height, width, location
        x : s.x
        y : s.y
        sizeX : s.sizeX
        sizeY : s.sizeY
    }
    d.layering = d.shape above s.container
}

-- No two specular objects should overlap
SpecularObject o1; SpecularObject o2 {
    LOCAL.disjointFn = ensure disjoint(o1.shape, o2.shape, 10.0)
}

-- No "in path" predicate because scene geometry shouldn't depend directly on a path
SpecularObject o {
    -- create mirror shape and put it in scene
    -- TODO: import SVG?
    /*
    o.shape = Rectangle {
        color : Colors.gray
        strokeWidth : 0.0
        -- TODO: sizes are temporary
        sizeX : 100.0
        sizeY : 20.0
    }
    */
    o.shape = Image {
        lengthX : 100.0
        lengthY : 10.0
        sizeX : o.shape.lengthX
        sizeY : o.shape.lengthY
        path  : "mirror.svg"
        x: o.shape.centerX
        y: o.shape.centerY
    }
}

LightSource l {
    -- TODO: has to have a location
    l.shape = Circle {
        color : Colors.lightKhaki
        r : 15.0
        strokeWidth : 0.0
    }
    l.text = Text {
        x : l.shape.x
        y : l.shape.y
        string : "L"
        color : Colors.black
    }
    l.textLayering = l.text above l.shape
}

Camera c {
    -- TODO: has to have a location
    /*
    c.shape = Circle {
        color : Colors.gray
        r : 20.0
        strokeWidth : 0.0
    }
    */
    c.shape = Image {
        lengthX : 20.0
        lengthY : 20.0
        r : max(c.shape.lengthX, c.shape.lengthY) / 2.0
        path  : "eye.svg"
        x: c.shape.centerX
        y: c.shape.centerY
        -- HACK: who's looking for sizeX and sizeY, and the length* naming convention is weird
        sizeX: c.shape.lengthX
        sizeY: c.shape.lengthY
    }
    c.text = Text {
        string : "C"
        color : Colors.black
    }
    c.textLayering = c.text above c.shape
    c.positionFn = encourage near(c.shape, c.text, 0.0, 20.0)
}

-- applies to all scene geometries
SceneGeometry o
where InOS(o, s) with Scene s {
    o.containFn = ensure contains(s.container, o.shape)
    o.layering  = o.shape above s.container
}

-- HACK: to make diffuse room below everybody
DiffuseObject d
where InOS(d, s) with Scene s {
    d.layering = d.shape below s.container
}

PathVertex v; PathSample ps
where InVP(v, p); OnLight(v)
with Path p; LightSource L {
    -- TODO: put the location on L's border
    v.x = L.shape.x
    v.y = L.shape.y
}

-- going into the eye
PathVertex v; Camera c; PathSample ps
where InVP(v, p); OnEye(v); e:= CreateEdge(v0, v)
with PathVertex v0; PathEdge e; Path p {
    -- TODO: put the location on E's border
    LOCAL.angle = atan2(v0.y - c.shape.y, v0.x - c.shape.x)
    v.x = c.shape.x + cos(LOCAL.angle) * c.shape.r
    v.y = c.shape.y + sin(LOCAL.angle) * c.shape.r
    c.shape.rotation = 180.0 + LOCAL.angle
}

PathVertex v; PathSample ps
where InVP(v, p); Hits(v, o)
with Path p; SpecularObject o {
    -- TODO: on border of mirror
    v.x = ?
    v.y = ?
}

PathVertex v; PathSample ps
where InVP(v, p); Hits(v, o)
with Path p; DiffuseObject o {
    -- TODO: pretty much anywhere on the room?
    v.x = ?
    v.y = ?
    v.onFn = ensure pointOn(v.x, v.y, o.shape, 0.0)
}

-- PathVertex v
-- where InVP(v, p); Hits(v, o) {
--     -- v.locationFn = ensure
-- }

PathEdge e; PathSample ps
where e := CreateEdge(v1, v2)
     -- Hits(v1, o1); Hits(v2, o2) -- for layering
with PathVertex v1, v2
     -- SceneGeometry o1, o2  -- for layering
{
     -- draw an arrow from v1's location to v2's location
     e.shape = Arrow {
         startX : v1.x
         startY : v1.y
         endX   : v2.x
         endY   : v2.y
         color  : Colors.lightKhaki
         thickness : 1.5
         arrowheadSize: 0.7
         -- arrowheadStyle: "arrowhead-1"  
     }
     -- e.layering1 = e.shape above o1.shape
     -- e.layering2 = e.shape above o2.shape
}

PathEdge e1; PathEdge e2; PathSample ps
where e1 := CreateEdge(v1, v2);
      e2 := CreateEdge(v2, v3);
      IsSpecular(v2);
      Hits(v2, o)
with PathVertex v1, v2, v3;
     SpecularObject o
{
    LOCAL.mirrorPadding = 1.0
    LOCAL.horizontalShift = sampleReal(o.shape.lengthX / -2.0 + 20.0, o.shape.lengthX / 2.0 - 20.0)
    override o.shape.rotation = mirrorAngle(e1.shape, e2.shape)
    override o.shape.centerX = mirrorPosX(e1.shape, e2.shape, v2.x, v2.y, o.shape.lengthY / 2.0 + LOCAL.mirrorPadding, LOCAL.horizontalShift)
    override o.shape.centerY = mirrorPosY(e1.shape, e2.shape, v2.x, v2.y, o.shape.lengthY / 2.0 + LOCAL.mirrorPadding, LOCAL.horizontalShift)
}

PathEdge e; SpecularObject o {
     -- ray should not intersect scene geometry
     LOCAL.disjointFn = ensure disjoint(o.shape, e.shape, 10.0)
}
PathEdge e; LightSource l {
     LOCAL.disjointFn = ensure disjoint(l.shape, e.shape, 10.0)
}
PathEdge e; Camera c {
     LOCAL.disjointFn = ensure disjoint(c.shape, e.shape, 10.0)
}


---------------------------NON-COMPILABLE CODE----------------------------------


/*
Path p; PathSample ps
where In(p, S) with Scene S {
      -- make path sample color
      -- label path with its string
}

-- Path vertex with various kinds of bounces

PathVertex v; PathSample ps
where InVP(v, p) with Path p {
     -- v.location = (?, ?)
}

-- TODO: work out the pathsample???


-- Rays


PathEdge e; SceneGeometry o; PathSample ps {
     -- ray should not intersect scene geometry
}

-- Do something at bounce point

-- Two edges that share a vertex
PathEdge e1; PathEdge e2; PathSample ps
where InVE(v1, e1); InVE(v2, e1); InVE(v2, e2); InVE(v3, e2);
      Hits(v2, o)
with PathVertex v1, v2, v3;
     SceneGeometry o {
     -- draw bounce normal for all bounces
}

-- Do something at specular bounce point

*/
