plugin "graphLayout" (400.0, 400.0)

-- TODO: Maybe apply the SVG transforms at the end of the program here:
-- https://dagrejs.github.io/project/dagre-d3/latest/demo/sentence-tokenization.html

-- TODO: Style the different node types differently
-- TODO: Penrose needs to draw the arrows to the edge of the ellipse only
-- TODO: Size graph to fit on the page

-- TODO: What are the varying values??
-- TODO: What are the objectives and constraints generated??
-- TODO: Maybe the right thing to do is do the conversion to Penrose space in the plugin
   -- Center the graph bbox at (0,0) (Penrose)
   -- Normalize all other coordinates to fit in (800,700)

const {
    -- const.padding = 10.0
    const.padding = 0.0
    const.nodePaddingX = 5.0
    const.nodePaddingY = 5.0
    const.edgeStroke = 2.0
    const.nodeColor = Colors.lightblue
    const.arrowColor = Colors.black

    -- Convert from "dagre space" to Penrose canvas space
    -- TODO: deal with (invariant) font sizes

    const.graphWidth = graphLayout["dagre_graph"]["width"]
    const.graphHeight = graphLayout["dagre_graph"]["height"]

    const.graphWidthHalf = const.graphWidth * 0.5
    const.graphHeightHalf = const.graphHeight * 0.5

    -- This is hand-tuned to just about fit the widest graph, optimization-graph.sub, because it makes more sense for all the examples to have the same scale factor
    const.scaleFactor = 0.065
    const.xShift = 0.0 -- const.graphWidth * 0.5
    const.yShift = 0.0 -- const.graphHeight * 0.5

    -- const.xShift = -200.0
    -- const.yShift = 200.0
    -- const.xShift = 0.0
    -- const.yShift = 0.0
    -- const.xShift = -550.0
    -- const.yShift = 300.0
    const.xFactor = 1.0
    -- const.yFactor = 1.0
    const.yFactor = -1.0 -- Why is this flipped?

    -- const.origin = Circle {
    -- 		 x : 0.0
    -- 		 y : 0.0
    -- 		 r : 10
    -- 		 color : Colors.red
    -- }

    const.canvasWidth = 800.0
    const.canvasHeight = 700.0

    const.canvas = Rectangle {
    		 x : 0.0
		 y : 0.0
		 sizeX : const.canvasWidth
 		 sizeY : const.canvasHeight
		 rotation : 0
		 strokeWidth : 3.0
		 strokeColor : Colors.blue
		 color : Colors.none
    }

    -- c > 0.2 ==> -c < -0.2
    -- ensure lessThanSq(-1.0 * const.scaleFactor, -0.5)
    ensure inRange(const.scaleFactor, 0.15, 1.0)
}

Colors {
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.darkgray = rgba(0.1, 0.1, 0.1, 1.0)
    Colors.gray = rgba(0.8, 0.8, 0.8, 1.0)
    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.pink = rgba(1.0, 0.4, 0.7, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    Colors.lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.sky = rgba(0.325, 0.718, 0.769, 1.0)
    Colors.lightsky = rgba(0.325, 0.718, 0.769, 0.25)
    Colors.lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    Colors.cyan = rgba(0.0, 1.0, 1.0, 1.0)
    Colors.purple = rgba(0.5, 0.0, 0.5, 1.0)
    Colors.white = rgba(1.0, 1.0, 1.0, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
    Colors.bluegreen = rgba(0.44, 0.68, 0.60, 1.0)
}

Node n {

-- Normalization approach borrowed from here: https://dagrejs.github.io/project/dagre-d3/latest/demo/sentence-tokenization.html

       n.shape = Ellipse { 
	 -- Normalize to [0,1], then to [-0.5,0.5], then scale to canvas dims
         -- x : (graphLayout[n.name]["x"] / const.graphWidth - 0.5) * const.canvasWidth
	 -- y : (graphLayout[n.name]["y"] / const.graphHeight - 0.5) * const.canvasHeight * const.yFactor

	 -- Preserve original graph ratio; don't stretch out
	 -- Transform first to be about (0,0)
	 -- Then scale both dimensions uniformly to fit exactly on the canvas (width or height) (TODO: Calculate scale factor?)
         x : (graphLayout[n.name]["x"] - const.graphWidthHalf) * const.scaleFactor
	 y : (graphLayout[n.name]["y"] - const.graphHeightHalf) * const.scaleFactor * const.yFactor

	 -- Note: you need to step the system to see this take effect
         rx : n.text.w / 2.0 + const.nodePaddingX
	 ry : n.text.h / 2.0 + const.nodePaddingY

	 color : const.nodeColor
	 strokeWidth : 0.0
       }

       -- Conservative approximation of ellipse (for `contains` function)
       -- n.shape2 = Circle {
       --   x : n.shape.x
       -- 	 y : n.shape.y
       -- 	 r : n.shape.rx
       -- 	 color : Colors.none
       -- 	 strokeWidth : 1.0
       -- 	 strokeColor : setOpacity(Colors.red, 0.2)
       -- }

       n.text = Text {
	 x : n.shape.x + const.padding
	 y : n.shape.y + const.padding
	 string : n.label
	 rotation : 0.0
	 color : Colors.black
       }

       n.text above n.shape

       encourage center(n.shape2)
       ensure contains(const.canvas, n.shape2, 5.0)
}

-- Ported from sty/tree.sty

ConstArg n {
	   override n.shape.color = setOpacity(Colors.sky, 0.9)
}

VaryingArg n {
	   override n.shape.color = setOpacity(Colors.orange, 0.9)
}

Const n {
            override n.shape.color = Colors.none
}

Node x; Node y {
   -- Try to make sure no labels overlap
   LOCAL.genRepelFn = encourage repel(x.shape, y.shape, 5.0)
}

-- TODO: factor out redundant code w/ lists
Node p; Node c
where to(p, c) {
      LOCAL.shape = Curve {
		  -- Shorten arrow to account for the bboxes of the shape
		  -- TODO: Account for arrowhead size in offset
      		  pathData : lineBetween(p.shape, c.shape)
		  strokeWidth : const.edgeStroke
		  color : const.arrowColor
		  fill : Colors.none
		  rotation : 0.0
		  rightArrowhead : True
		  arrowheadSize : 0.5
      }

      p.shape above LOCAL.shape
      c.shape above LOCAL.shape
}

-- Node p; Node c1; Node c2
-- where ParentOf2(p, c1, c2) {
--       LOCAL.shape1 = Arrow {
--       		  startX : p.shape.x
--       		  startY : p.shape.y
--       		  endX : c1.shape.x
--       		  endY : c1.shape.y
-- 		  color : const.arrowColor
-- 		  thickness : const.edgeStroke

--       }

--       LOCAL.shape2 = Arrow {
--       		  startX : p.shape.x
--       		  startY : p.shape.y
--       		  endX : c2.shape.x
--       		  endY : c2.shape.y
-- 		  color : const.arrowColor
-- 		  thickness : const.edgeStroke

--       }
-- }

-- Node p; Node c1; Node c2; Node c3
-- where ParentOf3(p, c1, c2, c3) {
--       LOCAL.shape1 = Arrow {
--       		  startX : p.shape.x
--       		  startY : p.shape.y
--       		  endX : c1.shape.x
--       		  endY : c1.shape.y
-- 		  color : const.arrowColor
-- 		  thickness : const.edgeStroke
--       }

--       LOCAL.shape2 = Arrow {
--       		  startX : p.shape.x
--       		  startY : p.shape.y
--       		  endX : c2.shape.x
--       		  endY : c2.shape.y
-- 		  color : const.arrowColor
-- 		  thickness : const.edgeStroke
--       }

--       LOCAL.shape3 = Arrow {
--       		  startX : p.shape.x
--       		  startY : p.shape.y
--       		  endX : c3.shape.x
--       		  endY : c3.shape.y
-- 		  color : const.arrowColor
-- 		  thickness : const.edgeStroke
--       }
-- }
