plugin "graphLayout" (400.0, 400.0)

-- TODO: Maybe apply the SVG transforms at the end of the program here:
-- https://dagrejs.github.io/project/dagre-d3/latest/demo/sentence-tokenization.html

-- TODO: Style the different node types differently
-- TODO: Penrose needs to draw the arrows to the edge of the ellipse only
-- TODO: Size graph to fit on the page

-- TODO: What are the varying values??
-- TODO: What are the objectives and constraints generated??
-- TODO: Maybe the right thing to do is do the conversion to Penrose space in the plugin
   -- Center the graph bbox at (0,0) (Penrose)
   -- Normalize all other coordinates to fit in (800,700)

const {
    -- const.padding = 10.0
    const.padding = 0.0
    const.edgeStroke = 2.0
    const.nodeWidth = 40.0
    const.nodeHeight = 20.0
    const.nodeColor = Colors.lightblue
    const.arrowColor = Colors.black

    -- Convert from "dagre space" to Penrose canvas space
    -- TODO: deal with (invariant) font sizes

    -- const.scaleFactor = 0.3 -- For comp. graph
    -- const.scaleFactor = 0.22 -- For opt. graph
    const.scaleFactor = ?
    const.xShift = ?
    const.yShift = ?

    -- const.xShift = -200.0
    -- const.yShift = 200.0
    -- const.xShift = 0.0
    -- const.yShift = 0.0
    -- const.xShift = -550.0
    -- const.yShift = 300.0
    const.xFactor = 1.0
    -- const.yFactor = 1.0
    const.yFactor = -1.0 -- Why is this flipped?

    const.origin = Circle {
    		 x : 0.0
		 y : 0.0
		 r : 10
		 color : Colors.red
    }

    const.canvas = Rectangle {
    		 x : 0.0
		 y : 0.0
		 sizeX : 800.0
		 sizeY : 700.0
		 rotation : 0
		 strokeWidth : 3.0
		 strokeColor : Colors.blue
		 color : Colors.none
    }

    -- c > 0.2 ==> -c < -0.2
    -- ensure lessThanSq(-1.0 * const.scaleFactor, -0.5)
    ensure inRange(const.scaleFactor, 0.15, 1.0)
}

Colors {
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.darkgray = rgba(0.1, 0.1, 0.1, 1.0)
    Colors.gray = rgba(0.8, 0.8, 0.8, 1.0)
    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.pink = rgba(1.0, 0.4, 0.7, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    Colors.lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.sky = rgba(0.325, 0.718, 0.769, 1.0)
    Colors.lightsky = rgba(0.325, 0.718, 0.769, 0.25)
    Colors.lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    Colors.cyan = rgba(0.0, 1.0, 1.0, 1.0)
    Colors.purple = rgba(0.5, 0.0, 0.5, 1.0)
    Colors.white = rgba(1.0, 1.0, 1.0, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
    Colors.bluegreen = rgba(0.44, 0.68, 0.60, 1.0)
}

Node n {
       n.shape = Ellipse { 
         x : const.xFactor * graphLayout[n.name]["x"] * const.scaleFactor + const.xShift
	 y : const.yFactor * graphLayout[n.name]["y"] * const.scaleFactor + const.yShift

         rx : const.nodeWidth
	 ry : const.nodeHeight

	 -- TODO: Don't seem to be able to get text dims here
         -- rx : n.text.w
	 -- ry : n.text.h

	 color : const.nodeColor
	 strokeWidth : 0.0
       }

       -- Conservative approximation of ellipse (for `contains` function)
       n.shape2 = Circle {
         x : n.shape.x
       	 y : n.shape.y
       	 r : n.shape.rx
       	 color : Colors.none
       	 strokeWidth : 1.0
       	 strokeColor : setOpacity(Colors.red, 0.2)
       }

       n.text = Text {
	 x : n.shape.x + const.padding
	 y : n.shape.y + const.padding
	 string : n.label
	 rotation : 0.0
	 color : Colors.black
       }

       n.text above n.shape

       encourage center(n.shape2)
       ensure contains(const.canvas, n.shape2, 5.0)
}

-- Ported from sty/tree.sty

ConstArg n {
	   override n.shape.color = setOpacity(Colors.sky, 0.9)
}

VaryingArg n {
	   override n.shape.color = setOpacity(Colors.orange, 0.9)
}

Const n {
            override n.shape.color = Colors.none
}

Node x; Node y {
   -- Try to make sure no labels overlap
   LOCAL.genRepelFn = encourage repel(x.shape, y.shape, 5.0)
}

-- TODO: factor out redundant code w/ lists
Node p; Node c
where to(p, c) {
      LOCAL.shape = Arrow {
      		  startX : p.shape.x
      		  startY : p.shape.y
      		  endX : c.shape.x
      		  endY : c.shape.y
		  color : const.arrowColor
		  thickness : const.edgeStroke
		  arrowheadSize : 0.5
      }

      p.shape above LOCAL.shape
      c.shape above LOCAL.shape

    -- -- Draw the arrow from y to x
    -- LOCAL.centerFn = encourage centerArrow(LOCAL.shape, p.shape, c.shape)

    -- -- Position y above x
    -- LOCAL.aboveFn = encourage above(p.shape, c.shape)

    -- -- Have sets 'fight' to be aligned with the superset's x-position
    -- LOCAL.equalFn = encourage equal(p.shape.x, c.shape.x)
}

-- Node p; Node c1; Node c2
-- where ParentOf2(p, c1, c2) {
--       LOCAL.shape1 = Arrow {
--       		  startX : p.shape.x
--       		  startY : p.shape.y
--       		  endX : c1.shape.x
--       		  endY : c1.shape.y
-- 		  color : const.arrowColor
-- 		  thickness : const.edgeStroke

--       }

--       LOCAL.shape2 = Arrow {
--       		  startX : p.shape.x
--       		  startY : p.shape.y
--       		  endX : c2.shape.x
--       		  endY : c2.shape.y
-- 		  color : const.arrowColor
-- 		  thickness : const.edgeStroke

--       }
-- }

-- Node p; Node c1; Node c2; Node c3
-- where ParentOf3(p, c1, c2, c3) {
--       LOCAL.shape1 = Arrow {
--       		  startX : p.shape.x
--       		  startY : p.shape.y
--       		  endX : c1.shape.x
--       		  endY : c1.shape.y
-- 		  color : const.arrowColor
-- 		  thickness : const.edgeStroke
--       }

--       LOCAL.shape2 = Arrow {
--       		  startX : p.shape.x
--       		  startY : p.shape.y
--       		  endX : c2.shape.x
--       		  endY : c2.shape.y
-- 		  color : const.arrowColor
-- 		  thickness : const.edgeStroke
--       }

--       LOCAL.shape3 = Arrow {
--       		  startX : p.shape.x
--       		  startY : p.shape.y
--       		  endX : c3.shape.x
--       		  endY : c3.shape.y
-- 		  color : const.arrowColor
-- 		  thickness : const.edgeStroke
--       }
-- }
