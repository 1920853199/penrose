Global {
   Global.width = 800.0
   Global.height = 700.0
   Global.pointSize = Global.width/100.0
   Global.thinStroke = Global.width/200.0
   Global.planeSize = 0.9*Global.height
}

Colors {
  Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
   Colors.black = rgba( 0.0, 0.0, 0.0, 1.0 )
   Colors.blue = rgba( 0.8, 0.7, 1.0, 0.2 )
   Colors.darkBlue = rgba( 0.2, 0.3, 0.6, 0.5 )
   Colors.red = rgba( 1.0, 0.0, 0.0, 0.5 )
}

forall HyperbolicPlane H {
   H.diskShape = Circle {
      x : 0.0
      y : 0.0
      r : Global.planeSize/2.0
      color : Colors.blue
      strokeWidth : Global.thinStroke
      strokeColor : Colors.black
      strokeStyle : "dashed"
      strokeDashArray : "10,10"
   }
}

forall Point p; HyperbolicPlane H
where In( p, H ) {
   p.dotShape = Circle {
      r : Global.pointSize/2.0
      strokeWidth : 0.0
      color : Colors.black
   }

   p.inDiskConstraint = ensure contains( H.diskShape, p.dotShape )
}

-- TODO: Fix that we can't add new functions with new names w/o backend complaining

forall IdealPoint p; HyperbolicPlane H
where In( p, H ) {
   p.angle = ?

   p.dotShape = Circle {
      x : H.diskShape.r * cos(p.angle)
      y : H.diskShape.r * sin(p.angle)
      r : Global.pointSize
      strokeWidth : 0.0
      color : Colors.black
   }

   delete p.inDiskConstraint
}

forall Horocycle h; IdealPoint p; HyperbolicPlane H
where IsCenter( p, h ); In( p, H ) {
   h.circleShape = Circle {
      r : Global.planeSize/4.0
      color : rgba( 1.0, 1.0, 1.0, 0.4 )
      strokeColor : Colors.black
      strokeWidth : Global.thinStroke
   }

   -- u = (h.center - H.center)/norm( h.center - H.center)
   LOCAL.R = H.diskShape.r
   LOCAL.c0x = H.diskShape.x
   LOCAL.c0y = H.diskShape.y
   LOCAL.c1x = h.circleShape.x
   LOCAL.c1y = h.circleShape.y
   LOCAL.ux = LOCAL.c1x - LOCAL.c0x
   LOCAL.uy = LOCAL.c1y - LOCAL.c0y
   LOCAL.m = sqrt( LOCAL.ux*LOCAL.ux + LOCAL.uy*LOCAL.uy )
   override p.dotShape.x = LOCAL.R * LOCAL.ux / LOCAL.m
   override p.dotShape.y = LOCAL.R * LOCAL.uy / LOCAL.m

   ensure tangentTo( H.diskShape, h.circleShape )
   layer h.circleShape above H.diskShape
}

forall Geodesic g; HyperbolicPlane `H` {
   g.shape = Circle {
      color : rgba( 1.0, 1.0, 1.0, 0.0 )
      strokeColor: Colors.darkBlue
      strokeWidth: Global.thinStroke
   }

   ensure orthogonalCircles( g.shape, H.diskShape )
   ensure inRange( g.shape.r, Global.planeSize*0.1, Global.planeSize*0.4 )
}

forall Geodesic g; IdealPoint p0; IdealPoint p1; HyperbolicPlane `H`
where PassesThrough( g, p0, p1 ) {
   LOCAL.cx = g.shape.x
   LOCAL.cy = g.shape.y

   -- r0 is distance from p0 to center of g's circle
   LOCAL.p0x = p0.dotShape.x
   LOCAL.p0y = p0.dotShape.y
   LOCAL.u0x = LOCAL.cx - LOCAL.p0x
   LOCAL.u0y = LOCAL.cy - LOCAL.p0y
   LOCAL.r0 = sqrt( LOCAL.u0x*LOCAL.u0x + LOCAL.u0y*LOCAL.u0y )

   -- Make sure the first point is on the geodesic's circle by
   -- setting its distance to the circle equal to the radius
   -- of the circle.
   ensure equalTo( LOCAL.r0, g.shape.r )

   -- Set the location of the second point to the reflection
   -- of the first point across the line between the geodesic's
   -- circle center, and the center of the Poincare disc

   -- First, compute the unit vector u in the direction of c
   LOCAL.magV = sqrt( LOCAL.cx*LOCAL.cx + LOCAL.cy*LOCAL.cy )
   LOCAL.ux = LOCAL.cx/LOCAL.magV
   LOCAL.uy = LOCAL.cy/LOCAL.magV

   -- Next, reflect p0 around u to get p1
   LOCAL.p0DotU = LOCAL.cx*LOCAL.p0x + LOCAL.cy*LOCAL.p0y
   -- Penrose gripes about the next two lines:
   -- argument of type BinOp not yet handled in pretty-printer;
   -- returning stopgap {"tag":"BinOp","contents":["Multiply",{"tag":"EPath","contents":{"tag":"FieldPath","contents":[{"tag":"BStyVar","contents":"Global"},"planeSize"]}},{"tag":"AFloat","contents":{"tag":"Fix","contents":0.1}}]}
   override p1.dotShape.x = LOCAL.p0DotU*LOCAL.ux
   override p1.dotShape.y = LOCAL.p0DotU*LOCAL.uy

   -- This is what I really want to do, but I can't get the multiply above to work:
   --override p1.dotShape.x = 2.0*LOCAL.p0DotU*LOCAL.ux - LOCAL.p0x
   --override p1.dotShape.y = 2.0*LOCAL.p0DotU*LOCAL.uy - LOCAL.p0y
}

