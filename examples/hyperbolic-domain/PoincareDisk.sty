Global {
   Global.width = 800.0
   Global.height = 700.0
   Global.pointSize = Global.width/100.0
   Global.thinStroke = Global.width/200.0
   Global.planeSize = 0.9*Global.height
}

Colors {
  Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
   Colors.black = rgba( 0.0, 0.0, 0.0, 1.0 )
   Colors.blue = rgba( 0.8, 0.7, 1.0, 0.2 )
   Colors.darkBlue = rgba( 0.2, 0.3, 0.6, 0.5 )
   Colors.red = rgba( 1.0, 0.0, 0.0, 0.5 )
}

forall HyperbolicPlane H {
   H.diskShape = Circle {
      x : 0.0
      y : 0.0
      r : Global.planeSize/2.0
      color : Colors.blue
      strokeWidth : Global.thinStroke
      strokeColor : Colors.black
      strokeStyle : "dashed"
      strokeDashArray : "10,10"
   }
}

forall Point p; HyperbolicPlane H
where In( p, H ) {
   p.dotShape = Circle {
      r : Global.pointSize/2.0
      strokeWidth : 0.0
      color : Colors.black
   }

   p.inDiskConstraint = ensure contains( H.diskShape, p.dotShape )
}

-- TODO: Fix that we can't add new functions with new names w/o backend complaining

forall IdealPoint p; HyperbolicPlane H
where In( p, H ) {
   p.angle = ?

   p.dotShape = Circle {
      x : H.diskShape.r * cos(p.angle)
      y : H.diskShape.r * sin(p.angle)
      r : Global.pointSize
      strokeWidth : 0.0
      color : Colors.black
   }

   delete p.inDiskConstraint
}

forall Horocycle h; IdealPoint p; HyperbolicPlane H
where IsCenter( p, h ); In( p, H ) {
   h.circleShape = Circle {
      r : Global.planeSize/4.0
      color : rgba( 1.0, 1.0, 1.0, 0.4 )
      strokeColor : Colors.black
      strokeWidth : Global.thinStroke
   }

   -- u = (h.center - H.center)/norm( h.center - H.center)
   LOCAL.R = H.diskShape.r
   LOCAL.c0x = H.diskShape.x
   LOCAL.c0y = H.diskShape.y
   LOCAL.c1x = h.circleShape.x
   LOCAL.c1y = h.circleShape.y
   LOCAL.ux = LOCAL.c1x - LOCAL.c0x
   LOCAL.uy = LOCAL.c1y - LOCAL.c0y
   LOCAL.m = sqrt( LOCAL.ux*LOCAL.ux + LOCAL.uy*LOCAL.uy )
   override p.dotShape.x = LOCAL.R * LOCAL.ux / LOCAL.m
   override p.dotShape.y = LOCAL.R * LOCAL.uy / LOCAL.m

   ensure tangentTo( H.diskShape, h.circleShape )
   layer h.circleShape above H.diskShape
}

forall Geodesic g; HyperbolicPlane `H` {
   g.shape = Circle {
      color : rgba( 1.0, 1.0, 1.0, 0.0 )
      strokeColor: Colors.darkBlue
      strokeWidth: Global.thinStroke
   }

   ensure orthogonalCircles( g.shape, H.diskShape )
   --ensure inRange( g.shape.r, Global.planeSize*0.2, Global.planeSize*0.4 )
}

