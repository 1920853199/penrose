Global {
   Global.width = 800.0
   Global.height = 700.0
   Global.pointSize = Global.width/100.0
   Global.thinStroke = Global.width/200.0
   Global.planeSize = 0.9*Global.height
   Global.labelSize = 32.0
}

Colors {
   Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
   Colors.black = rgba( 0.0, 0.0, 0.0, 1.0 )
   Colors.blue = rgba( 0.8, 0.7, 1.0, 0.2 )
   Colors.darkBlue = rgba( 0.2, 0.3, 0.6, 0.5 )
   Colors.red = rgba( 1.0, 0.0, 0.0, 0.5 )
   Colors.none = rgba( 0.0, 0.0, 0.0, 0.0 )
}

forall HyperbolicPlane H {
   H.diskShape = Circle {
      center : (0.0, 0.)
      r : Global.planeSize/2.0
      color : Colors.blue
      strokeWidth : Global.thinStroke
      strokeColor : Colors.black
      strokeStyle : "dashed"
      strokeDashArray : "10,10"
   }

   H.text = Text {
      string: "H^2"
      x: 0.8*H.diskShape.r
      y: 0.8*H.diskShape.r
      color: Colors.black
      fontSize: Global.labelSize
   }
}

forall Point p; HyperbolicPlane H
where In( p, H ) {
   p.dotShape = Circle {
      r : Global.pointSize/2.0
      strokeWidth : 0.0
      color : Colors.black
   }

   p.inDiskConstraint = ensure contains( H.diskShape, p.dotShape )

   LOCAL.ux = p.dotShape.x / H.diskShape.r
   LOCAL.uy = p.dotShape.y / H.diskShape.r

   p.text = Text {
      string: p.label
      x: p.dotShape.x + 1.1*Global.labelSize*LOCAL.ux
      y: p.dotShape.y + 1.1*Global.labelSize*LOCAL.uy
      color: Colors.black
      fontSize: Global.labelSize
   }
}

-- TODO: Fix that we can't add new functions with new names w/o backend complaining

forall IdealPoint p; HyperbolicPlane H
where In( p, H ) {
   p.angle = ?

   p.dotShape = Circle {
      center : (H.diskShape.r * cos(p.angle), H.diskShape.r * sin(p.angle))
      r : Global.pointSize
      strokeWidth : 0.0
      color : Colors.black
   }

   delete p.inDiskConstraint
}

forall Horocycle h; IdealPoint p; HyperbolicPlane H
where IsCenter( p, h ); In( p, H ) {

   h.r = ?
   LOCAL.R = Global.planeSize/2.0
   LOCAL.px = p.dotShape.x
   LOCAL.py = p.dotShape.y
   LOCAL.m = sqrt( LOCAL.px*LOCAL.px + LOCAL.py*LOCAL.py )
   LOCAL.ux = LOCAL.px/LOCAL.m
   LOCAL.uy = LOCAL.py/LOCAL.m

   h.circleShape = Circle {
      r : h.r
      color : rgba( 1.0, 1.0, 1.0, 0.4 )
      strokeColor : Colors.black
      strokeWidth : Global.thinStroke
   }
   h.circleShape.x = ( LOCAL.R - h.r )*LOCAL.ux
   h.circleShape.y = ( LOCAL.R - h.r )*LOCAL.uy
   layer h.circleShape above H.diskShape
   ensure inRange( h.r, 0.1*LOCAL.R, 0.5*LOCAL.R )
}

forall Geodesic g; HyperbolicPlane `H` {
   g.shape = Circle {
      color : Colors.none
      strokeColor: Colors.darkBlue
      strokeWidth: Global.thinStroke
   }

   g.orthogonalConstraint = ensure orthogonalCircles( g.shape, H.diskShape )
   ensure inRange( g.shape.r, Global.planeSize*0.1, Global.planeSize )
}

forall Geodesic g; IdealPoint p0; IdealPoint p1; HyperbolicPlane `H`
where PassesThrough( g, p0, p1 ) {

   -- Given the locations of two points p0, p1 on the boundary of
   -- the Poincare disk, we'll explicitly compute the center and
   -- radius of the circle orthogonal to the disk boundary, passing
   -- through these two points.

   -- remove the constraint that g should be orthogonal to H;
   -- orthogonality will be enforced by construction here
   delete g.orthogonalConstraint

   -- First, get some short names
   -- R = radius of Poincare disk
   LOCAL.R = H.diskShape.r
   -- p0 = center of first point
   LOCAL.p0x = p0.dotShape.x
   LOCAL.p0y = p0.dotShape.y
   -- p1 = center of second point
   LOCAL.p1x = p1.dotShape.x
   LOCAL.p1y = p1.dotShape.y

   -- Compute distance b from center of H to center of g
   LOCAL.dotP0P1 = LOCAL.p0x*LOCAL.p1x + LOCAL.p0y*LOCAL.p1y
   LOCAL.b = LOCAL.R/sqrt((1.0+LOCAL.dotP0P1/(LOCAL.R*LOCAL.R))/2.0)

   -- Compute unit vector u between p and q
   LOCAL.vx = LOCAL.p0x + LOCAL.p1x
   LOCAL.vy = LOCAL.p0y + LOCAL.p1y
   LOCAL.m = sqrt( LOCAL.vx*LOCAL.vx + LOCAL.vy*LOCAL.vy )
   LOCAL.ux = LOCAL.vx / LOCAL.m
   LOCAL.uy = LOCAL.vy / LOCAL.m

   -- Set center of g's circle
   g.shape.x = LOCAL.b * LOCAL.ux
   g.shape.y = LOCAL.b * LOCAL.uy

   -- Set radius of g's circle
   LOCAL.wx = g.shape.x - LOCAL.p0x
   LOCAL.wy = g.shape.y - LOCAL.p0y
   g.shape.r = sqrt( LOCAL.wx*LOCAL.wx + LOCAL.wy*LOCAL.wy )
}

forall Geodesic g; Geodesic h; IdealPoint p
where PerpendicularTo( g, h, p ) {

   LOCAL.cx = g.shape.x
   LOCAL.cy = g.shape.y
   LOCAL.px = p.dotShape.x
   LOCAL.py = p.dotShape.y
   LOCAL.ux = LOCAL.cx - LOCAL.px
   LOCAL.uy = LOCAL.cy - LOCAL.py
   LOCAL.d = sqrt( LOCAL.ux*LOCAL.ux + LOCAL.uy*LOCAL.uy )

   g.shape.strokeColor = Colors.red
   
   encourage equal( g.shape.r, LOCAL.d )
   ensure orthogonalCircles( g.shape, h.shape )
}

-- Diagram-specific constants

IdealPoint `pi` {
   override `pi`.angle = -110.0
}

IdealPoint `pj` {
   override `pj`.angle = 90.0
}

IdealPoint `pk` {
   override `pk`.angle = 170.0
}

IdealPoint `pl` {
   override `pl`.angle = 10.0
}

Geodesic `gkl` {
   `gkl`.shape.strokeStyle = "dashed"
}

