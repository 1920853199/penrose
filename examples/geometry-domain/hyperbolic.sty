Colors {
    -- Keenan palette
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.midnightblue = rgba(0.14, 0.16, 0.52, 1.0)
    Colors.lightslategray = rgba(0.50, 0.51, 0.69, 1.0)
    Colors.silver = rgba(0.71, 0.72, 0.79, 1.0)
    Colors.gainsboro = rgba(0.87, 0.87, 0.87, 1.0)

    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.pink = rgba(1.0, 0.4, 0.7, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.sky = rgba(0.325, 0.718, 0.769, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
}

G {
  -- Drawing parameters
  G.padding = 10.0
  G.numArcPts = 30
  G.stroke = 2.0
  G.spacing = 150.0
  G.pi = 3.14159
  G.two_pi = 6.28319
  G.toScreen = 200.0 -- Math space to screen space

  -- Poincare disk: Unit disk at the origin
  G.diskRadius = 1.0

  G.disk = Circle {
  	 x : 0.0
	 y : 0.0
	 r : G.toScreen * G.diskRadius
	 color : setOpacity(Colors.blue, 0.1)
	 strokeWidth : 1.0
	 strokeColor : Colors.black
  }
}

Point p {
      -- Point on hyperboloid of two sheets: x^2 + y^2 - z^2 = -1, where z > 0
      -- That is, <p, p>_L = 1 (with the Lorenz inner product)
      p.x = ?
      p.y = ?
      p.z = calcZ(p.x, p.y) -- Satisfies hyperbola by construction
      p.vec_math = [p.x, p.y, p.z]

      -- Is there a nicer way to state this (or easier way to satisfy this?)
      -- p.onHyperbolaFn = ensure hasLorenzNorm(p.vec_math, -1.0 * G.diskRadius)
      -- p.topSheetFn = ensure lessThan(-1.0 * p.z, 0.0) -- z > 0 (TODO write greaterThan)
      -- TODO: the vectors don't seem to quite satisfy all the constraints...

      p.vec_disk = toDisk(p.vec_math)
      p.vec_screen = diskToScreen(p.vec_disk, G.toScreen)

      p.shape = Circle {
	x : get(p.vec_screen, 0)
	y : get(p.vec_screen, 1)
	r : 3.0
	color : Colors.midnightblue
	strokeWidth : 1.0
	strokeColor : Colors.midnightblue
      }

      p.text = Text {
      	     x : p.shape.x + 10.0
      	     y : p.shape.y + 10.0
      	     string : p.label
      }

      -- p.labelFn = encourage near(p.shape, p.text, G.padding)
      p.layering = p.shape above G.disk
}

-- Some test points on the hyperboloid
Point `p` {
      override `p`.x = -5.0
      override `p`.y = -5.0
      -- override `p`.x = 0.0
      -- override `p`.y = 0.0

      override `p`.z = calcZ(`p`.x, `p`.y)
}

Point `q` {
      override `q`.x = -1.0
      override `q`.y = -3.0
      override `q`.z = calcZ(`q`.x, `q`.y)
}

Point `r` {
      override `r`.x = -1.0
      override `r`.y = 2.0
      override `r`.z = calcZ(`r`.x, `r`.y)
}

Segment e
where e := MkSegment(p, q)
with Point p; Point q {
     -- Line on hyperbola (geodesic)

     e.arcPath = slerpHyp(p.vec_math, q.vec_math, G.numArcPts)
     e.screenspacePath = pathToDiskAndScreen(e.arcPath, G.toScreen)

     -- Draw a path using the slerp'ed points
     e.shape = Curve {
     	     pathData : pathFromPoints(e.screenspacePath)
	     strokeWidth : 2.0
	     fill : Colors.none
	     color : Colors.midnightblue
	     rotation : 0.0
     }

     e.layering1 = p.shape above e.shape
     e.layering2 = q.shape above e.shape
}

Ray r {
    r.length = 100.0
}

-- Maybe it would make more sense to make the triangle from the segments that have already been made.

Triangle t
where t := MkTriangleP(p, q, r)
with Point p; Point q; Point r {
     t.arcPath_pq = slerpHyp(p.vec_math, q.vec_math, G.numArcPts)
     t.screenspacePath_pq = pathToDiskAndScreen(t.arcPath_pq, G.toScreen)

     t.arcPath_qr = slerpHyp(q.vec_math, r.vec_math, G.numArcPts)
     t.screenspacePath_qr = pathToDiskAndScreen(t.arcPath_qr, G.toScreen)

     t.arcPath_rp = slerpHyp(r.vec_math, p.vec_math, G.numArcPts)
     t.screenspacePath_rp = pathToDiskAndScreen(t.arcPath_rp, G.toScreen)

     t.shape = Curve {
     	     pathData : join(t.screenspacePath_pq, t.screenspacePath_qr, t.screenspacePath_rp) -- Connect them in a particular order
	     strokeWidth : 0.0
	     fill : setOpacity(Colors.blue, 0.2)
	     color : Colors.none
	     rotation : 0.0
     }
}

Ray r
with Segment s; Point p; Point q
where r := PerpendicularBisector(s); s := MkSegment(p, q) {
      r.rayDist = 5.0 -- TODO: what's the right length to use here?
      r.tail_vec_math = halfwayPointHyp(p.vec_math, q.vec_math) -- The part w/o arrow, TODO
      r.head_vec_math = normalOnHyp(p.vec_math, q.vec_math, r.tail_vec_math, r.rayDist) -- TODO

      r.arcPath = slerpHyp(r.tail_vec_math, r.head_vec_math, G.numArcPts)
      r.screenspacePath = pathToDiskAndScreen(r.arcPath, G.toScreen)
      
      r.shape = Curve {
      	      pathData : pathFromPoints(r.screenspacePath) -- TODO: why are these NaNing?
	      strokeWidth : 2.0
	      fill : Colors.none
	      color : Colors.midnightblue
	      rotation : 0.0
	      rightArrowhead : True
      }

      -- TODO: perpendicular mark
}

Point p
where p := Midpoint(s); s := MkSegment(a, b)
with Segment s; Point a; Point b {
     override p.vec_math = halfwayPointHyp(a.vec_math, b.vec_math)
}

-- Assuming the segments share a point
Angle theta
where theta := AngleBetween(a, b); a := MkSegment(p, q); b := MkSegment(p, r) 
with Segment a; Segment b; Point p; Point q; Point r {

     theta.radius = G.pi / 5.0 -- TODO: should this depend on distance from the center?
     theta.arcPath = arcPathHyp(p.vec_math, q.vec_math, r.vec_math, theta.radius)
     theta.arcPath_screenspace = pathToDiskAndScreen(theta.arcPath, G.toScreen)

     theta.shape = Curve {
     		 pathData : pathFromPoints(theta.arcPath_screenspace)
		 strokeWidth : 1.5
		 color : Colors.lightslategray
		 fill : Colors.none
     }
}

Ray r
with Angle theta; Segment a; Segment b; Point x; Point y; Point z
where r := Bisector(theta); theta := AngleBetween(a, b); a := MkSegment(x, y); b := MkSegment(x, z) {

      -- TODO: note that there's a decent amount of code shared between here and the PerpendicularBisector selector
      -- Move some into the basic Ray selector?
      r.rayDist = 5.0 -- TODO: what's the right length to use here?
      r.tail_vec_math = x.vec_math
      r.head_vec_math = angleBisectorHyp(x.vec_math, y.vec_math, z.vec_math, r.rayDist)

      r.arcPath = slerpHyp(r.tail_vec_math, r.head_vec_math, G.numArcPts)
      r.screenspacePath = pathToDiskAndScreen(r.arcPath, G.toScreen)
      
      r.shape = Curve {
      	      pathData : pathFromPoints(r.screenspacePath) -- TODO: why are these NaNing?
	      strokeWidth : 2.0
	      fill : Colors.none
	      color : Colors.midnightblue
	      rotation : 0.0
	      rightArrowhead : True
      }

      -- TODO: make two angle bisector marks
}
